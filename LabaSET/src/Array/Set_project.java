package Array;
/*

//реализовать класс множевыство на массиве
public class Set_project{

    private static class Position{
        int index; //номер ячейки
        int pos; //номер бита в числе

        public Position(int i, int p){
            index = i;
            pos = p;
        }
    }
    private static final int leftBit = 0b10000000000000000000000000000000; //маска зануления всего кроме последнего бита
    private int set[]; // массив множества, четырехбайтовые числа, диапазон от start до end
    private int start, end; // начало и конец диапазона
    private int pos_zero = 0; // позиция нуля в массиве


    //Конструктор по умолчанию
    public Set_project(){
        new Set_project(-100,100);
    }

    public Set_project(int from, int till) {
        //1. Проверка корректности входных данных
        // Входящие from и till не должны быть равны 0 или начало больше конца
        // если да присваиваем start = from и end = till;

        pos_zero = 0;

        //2 случая
        //1. Если start меньше 0
            // Подсчет размера отрицательной и положительной частей массива отдельно
            // 1. Вычисляем количество ячеек для отрицательной части (если start >= -31, то 1, иначе start/32)
            // 2. Вычисляем количество ячеек для положительной части (если end <= 31, то 1, иначе end/32)
            // 3. Выделяем память под общее количество ячеек, равное сумме ячеек для отрицательной и положительной частей
            // 4. Задаем позицию нуля в массиве, равную количеству ячеек для положительной части

        //2. Если start больше или равен 0
            // 1. Вычисляем количество ячеек в массиве, исходя из диапазона чисел (end/32 - start/32 +  1)
            // Задаем позицию нуля в массиве, равную -1
    }


    // Копирующий конструктор
    public Set_project(Set_project B){
        //1. Присваиваем новые значения start, end, pos_zero
        //2. Копируем полученный массив в this.set с помощью for
    }
    //Внутренний метод для проверки множества на пустоту
    private boolean isEmpty(){
        //Проверка в цикле до конца на неравенство 0
        //1. Если найдена такое число - вывод false
        //2. Иначе - вывод true
    }

    //Определение наличия значения
    public boolean MEMBER(int x) {
        //1. Проверка на пустоту isEmpty()) - возвращаем false
        //2. Проверка на входимость в диапозон - возвращаем false
        //3. Находим позицию х в массиве с помощью метода findPos()
        //4. Если найденный бит равен 1, то true, иначе false
    }

    // Проверка, что бит в указанной позиции не равен 0
    private boolean NoZero(Position p){
        //1. Берем значение из массива по позиции p
        //2. Выполняем побитовой сдвиг вправо на количество позиций p.pos.
        //3. Выполняется побитовая операция И между set[p.index] и результатом сдвига
        //4. Возвращаем результат сравнения с 0 и инвертируем его.
    }
    //Поиск позиции
    private Position findPos(int x){
        //1. Берем х по модулю

        //3 случая
        //1. Если старт в 0 - возвращаем новую позицию index = x / 32 и pos = x % 32
        //2. Если старт < нуля - возвращаем новую позицию index = pos_zero + x / 32 и pos = x % 32
        //3. Если старт > 0 - возвращаем новую позицию index = (x - start) / 32 и pos = (x - start) % 32)2
    }

    public Set_project UNION(Set_project B){
        //1. Проверка пустоты множества А isEmpty()) true - возвращаем В
        //2. Проверка пустоты множества В isEmpty()) true - возвращаем А
        //3. Вызов приватного метода AorB для выполнения операции объединения множеств
    }

    public Set_project INTERSECTION(Set_project B){
        //1. Проверяем наличие пустоты в множествах А и В isEmpty()) true - возвращаем null
        //2. Проверяем на равенство множеств А и В
            // Если множества А и В равны, возвращем множество А
        //3. Проверяем наличие пересечения между интервалами start и end множеств
            // Если интервалы множеств не пересекаются, возвращаем null
        //4. Вызываем приватный метод AinB для выполнения операции пересечения множеств
    }

    public Set_project DIFFERENCE(Set_project B){
        //1. Проверяем, пустое ли множество А true - возвращаем В
        //2. Проверяем, пустое ли множество B true - возвращаем A

        //3. Проверяем на равенство множеств А и В
            // Если множества А и В равны, возвращем множество NULL
        //4. Вызываем приватный медот AsubB для выполнения операции нахождения разности множеств
    }

    public Set_project MERGE(Set_project B){
        //1. Проверяем наличие пустоты в множествах А и В isEmpty()) true - возвращаем null
        //2. Проверяем, пересекаются ли множества А и В, функцией AinB true - возвращаем null
        //3. Вызываем приватный метод AorB для выполнения операции объединения множеств
    }

    //Побитовое ИЛИ
    private Set_project AorB(Set_project B){
        //1. Создание нового множества C с определением самого левого start и самого правого end из множеств B и А
        //2. Проход по множеству A, выполняя побитовое ИЛИ и добавляя все элементы в множество C,
        //3. Проход по множеству B, выполняя побитовое ИЛИ и добавляя все элементы в множество C
        //4. Возвращение нового множества С
    }
    //Вывод общего подмножества А и В
    private Set_project AinB(Set_project B){
        //1. Определение начала(максимум из start множества B и start множества А)
        // и конца(минимум из end множества B и end множества А) - inter_start и inter_end
        //2. Создаем новое множество С с интервалом пересечения найденными началом и концом

        //3. Находим позиции начала пересечения в каждом множестве используя findPos(inter_start)
        //4. Проходим по интервалу пересечения множеств(inter_start и inter_end)
        // и выполняем операцию побитового И для каждого элемента, добавляя результат в множество С
        //5. Возвращаем новое множество С
    }

    //Побитовая разность А и В
    private Set_project AsubB(Set_project B){
        //1. Создаем новое множество, равное множеству А

        //2. Определяем начало второго множества
        //3. Находим конец пересечения, если end меньше или равен B.end. Иначе используем метод findPos(B.end).index

        //4. Проходим по C (равному А) и вычитаем все элементы множества В (для этого делаем побитовое И отрицания ячейки В)
        //5. Возвращаем новое множество С
    }
    //пупу пу заварюка кофейку

    //Обнуление множества
    public void MAKENULL(){
        //Обнуляем массив в цикле приравнивая его элементы к 0
    }

    public void INSERT(int x){
        //1. Проверка на входимость х в диапазон массива
        //2. Находим позицию х в массиве с помощью метода findPos()
        //3. Выполняем побитовое ИЛИ с четырехбайтовым числом, содержащим 1 в найденном бите.
    }

    public void DELETE(int x){
        //1. Проверка на входимость х в диапазон массива
        //2. Находим позицию х в массиве с помощью метода findPos()
        //3. Выполняем побитовое И с результатом отрицания четырехбайтового числа с 1 в найденном бите.
    }

    public void ASSIGN(Set_project B){
        //1. Переопределяем start, end и pos_zero
        //2. Копируем массив B.set в массив set текущего объекта поэлементно.
    }
    //!!!
    public int MIN(){
        //1. Проходим по каждой ячейке массива, начиная с 0
            //1. Проверка на неравенство с 0
                //1. Перебираем все маски с одной 1 слева направо
                    // Вычисляем маску с единицей сдвинутую на j позиций вправо
                    // Как только находим первую единицу, возвращаем число, которому она эквивалентна в массиве
        // Если массив пустой, выбрасываем исключение
    }
    public int MAX(){
        //1. Проходим по каждой ячейке массива, начиная с конца
            //1. Поиск ячейки в которой есть хотя бы одна 1
                //1. Объявляем переменные mask и maskCounter
                //2. Перебираем все битовые маски с одной 1, начиная с самого правого бита (31) и двигаясь к левому (0).
                    // Формируем mask, в которой один бит сдвигается влево на количество позиций, определяемых maskCounter
                    // Как только находим первую единицу((set[i] & mask) != 0), возвращаем число, которому она эквивалентна в массиве (32 * i + j), где i - индекс текущего элемента массива, а j - индекс текущей позиции бита
                    // Увеличиваем maskCounter
        // Если массив пустой, выбрасываем исключение
    }

    public boolean EQUAL(Set_project B){
        //1. Проверяется, равны ли оба множества. Если равны, возвращается значение "false".
        //2. Проверяется, существуют ли оба множества. Если хотя бы одно из множеств не существует, возвращается значение "false".

        //3. Проверяем, пересекаются ли интервалы множеств(сравнивая начало и конец текущего и множества b), если нет, сразу вернем false
        //4. Проверяем множества на пересечение
        //5. Выбираем множество, в котором 1 встречается раньше оставшиеся записываем в другую переменную
        //6. Находим позицию начала пересечения двух множеств

        //3 проверки
        //7. Проверяем левую часть на нули (не входящую в пересечение)
            // Если там есть хотя бы одна 1, множества не могут быть равны

        //8. Проверяем пересечение

        //9. Проверяем оставшуюся часть множества, end которой оказалась дальше
            // Если там есть хотя бы одна 1, множества не могут быть равны

        // Если все проверки пройдены, возвращаем true
    }



    public Set_project FIND(Set_project B, int x){
        //1. Проверяем, пусто ли текущее множество (this), или х находится вне его границ
            //1. Находим позицию x в B множества с помощью findPos()
            //2. Проверяем, существует ли позиция (не равна 0) и если да, возвращаем множество B

        //2. Проверяем, пусто ли множество B, или х находится вне его границ
            //1. Находим позицию x в текущем множестве с помощью findPos()
            //2. Проверяем, существует ли позиция (не равна 0) и если да, возвращаем текущее множество

        //3. Возвращаем null, если такого элемента нет ни в одном из множеств
    }

    public void print(){ // Вывод на экран
        //Вывод позиции 0, начала и конца текущего множества
        //Вывод элементов множества
    }
}


 */

/*
        package Array;

//реализовать класс множество на массиве
public class Set {
    private static class Position{
        int index; //номер ячейки
        int pos; //номер бита в числе

        public Position(int i, int p){
            index = i;
            pos = p;
        }
    }
    private static final int leftBit = 0b10000000000000000000000000000000; //маска зануления всего кроме последнего бита
    private int set[]; // массив множества, четырехбайтовые числа, диапазон от start до end
    private int start, end; // начало и конец диапазона
    private int pos_zero = 0; // позиция нуля в массиве

    public Set(){
        new Set(-100,100);
    }

    /*
    //1. Проверка корректности входных данных
        // Входящие from и till не должны быть равны 0 или начало больше конца
        // если да присваиваем start = from и end = till;

        pos_zero = 0;

        //2 случая
        //1. Если start меньше 0
            // Подсчет размера отрицательной и положительной частей массива отдельно
            // 1. Вычисляем количество ячеек для отрицательной части (если start >= -31, то 1, иначе start/32)
            // 2. Вычисляем количество ячеек для положительной части (если end <= 31, то 1, иначе end/32)
            // 3. Выделяем память под общее количество ячеек, равное сумме ячеек для отрицательной и положительной частей
            // 4. Задаем позицию нуля в массиве, равную количеству ячеек для положительной части

        //2. Если start больше или равен 0
            // 1. Вычисляем количество ячеек в массиве, исходя из диапазона чисел (end/32 - start/32 +  1)
            // Задаем позицию нуля в массиве, равную -1

    public Set(int from, int to) {
        if ((from == 0 && to == 0) || (from > to)) return;
        start = from;
        end = to;

        pos_zero = 0;
        //2 случая
        if (start < 0){ // Если Старт отрицательный, то высчитываем положительную и отрицательную часть массива отдельно
            int negativeLen = start >= -31? 1 : start/32;
            int positiveLen = end <= 31 ? 1 : end/32;
            set = new int[Math.abs(negativeLen) + positiveLen];
            pos_zero = positiveLen;
        }

        if (start >= 0) { // Если старт положительный, то ячеек в массиве будет (end/32 - start/32 +  1), а позиции нуля присвоим -1
            set = new int[end/32 - start/32 +  1];
            pos_zero = -1;
        }
    }

    // Копирующий конструктор
    //1. Присваиваем новые значения start, end, pos_zero
    //2. Копируем полученный массив в this.set с помощью for
    public Set(Set B){
        start = B.start;
        end = B.end;
        pos_zero = B.pos_zero;
        set = new int[B.set.length];
        for (int i = 0; i < set.length; i ++){
            set[i] = B.set[i];
        }
    }

    //Определение наличия значения
    //1. Проверка на пустоту isEmpty()) - возвращаем false
    //2. Проверка на входимость в диапозон - возвращаем false
    //3. Находим позицию х в массиве с помощью метода findPos()
    //4. Если найденный бит равен 1, то true, иначе false
    public boolean MEMBER(int x) {
        if(isEmpty()) return false; // Если множество пустое, возвращаем false
        if (x < start || x > end) return false; //Находим позицию х в массиве с помощью метода findPos()
        Position p = findPos(x);
        return isNotZero(p); //Если найденный бит равен 1, то true, иначе false
    }

    // Проверка, что бит в указанной позиции не равен 0
    //1. Берем значение из массива по позиции p
    //2. Выполняем побитовой сдвиг вправо на количество позиций p.pos.
    //3. Выполняется побитовая операция И между set[p.index] и результатом сдвига
    //4. Возвращаем результат сравнения с 0 и инвертируем его.
    private boolean isNotZero(Position p){
        return !((set[p.index] & leftBit >>> p.pos) == 0);
    }

    //1. Проверка пустоты множества А isEmpty()) true - возвращаем В
    //2. Проверка пустоты множества В isEmpty()) true - возвращаем А
    //3. Вызов приватного метода AorB для выполнения операции объединения множеств
    public Set Union(Set B){
        if (isEmpty()) return B;
        if (B.isEmpty()) return this;
        return AorB(B);
    }

    //1. Проверяем наличие пустоты в множествах А и В isEmpty()) true - возвращаем null
    //2. Проверяем на равенство множеств А и В
    // Если множества А и В равны, возвращем множество А
    //3. Проверяем наличие пересечения между интервалами start и end множеств
    // Если интервалы множеств не пересекаются, возвращаем null
    //4. Вызываем приватный метод AinB для выполнения операции пересечения множеств
    public Set Intersection(Set B){
        if (isEmpty() || B.isEmpty()) return null;
        if (this.equal(B)) return this;
        if (B.end < start || B.start > end) return null;
        return AinB(B);
    }


    //1. Проверяем, пустое ли множество А true - возвращаем В
    //2. Проверяем, пустое ли множество B true - возвращаем A
    //3. Проверяем на равенство множеств А и В
    // Если множества А и В равны, возвращем множество NULL
    //4. Вызываем приватный медот AsubB для выполнения операции нахождения разности множеств
    public Set Difference(Set B){
        if (isEmpty()) return B;
        if (B.isEmpty()) return this;
        if (this.equal(B)) return null;
        return AsubB(B);
    }

    //1. Проверяем наличие пустоты в множествах А и В isEmpty()) true - возвращаем null
    //2. Проверяем, пересекаются ли множества А и В, функцией AinB true - возвращаем null
    //3. Вызываем приватный метод AorB для выполнения операции объединения множеств
    public Set Merge(Set B){
        if (isEmpty() || B.isEmpty()) return null;
        if (AinB(B) != null) return null;
        return AorB(B);
    }

    //Обнуляем массив в цикле приравнивая его элементы к 0
    public void MakeNull(){
        for (int i = 0; i < set.length; i++){
            set[i] = 0;
        }
    }

    //1. Проверка на входимость х в диапазон массива
    //2. Находим позицию х в массиве с помощью метода findPos()
    //3. Выполняем побитовое ИЛИ с четырехбайтовым числом, содержащим 1 в найденном бите.
    public void Insert(int x){
        if (x < start || x > end) return;
        Position p = findPos(x);

        set[p.index] |= leftBit >>> p.pos;
    }

    //1. Проверка на входимость х в диапазон массива
    //2. Находим позицию х в массиве с помощью метода findPos()
    //3. Выполняем побитовое И с результатом отрицания четырехбайтового числа с 1 в найденном бите.
    public void Delete(int x){
        if (x < start || x > end) return;
        Position p = findPos(x);

        set[p.index] &= ~(leftBit >>> p.pos);
    }

    //1. Переопределяем start, end и pos_zero
    //2. Копируем массив B.set в массив set текущего объекта поэлементно.
    public void Assign(Set B){
        start = B.start;
        end = B.start;
        pos_zero = B.pos_zero;

        set = new int[B.set.length];
        for (int i = 0; i < set.length; i ++){
            set[i] = B.set[i];
        }

    }

    //1. Проходим по каждой ячейке массива, начиная с 0
    //1. Проверка на неравенство с 0
    //1. Перебираем все маски с одной 1 слева направо
    // Вычисляем маску с единицей сдвинутую на j позиций вправо
    // Как только находим первую единицу, возвращаем число, которому она эквивалентна в массиве
    // Если массив пустой, выбрасываем исключение
    public int Min(){
        for (int i = 0; i < set.length; i++){
            if (set[i] != 0){
                int mask;
                for (int j = 0; j < 32; j++){
                    mask = leftBit >> j;
                    if ((set[i] & mask) != 0){
                        return (32 * i - (start > 0 ? 0 : start % 32) + j );
                    }
                }

            }
        }
        throw new RuntimeException("Set is empty");
    }

    //1. Проходим по каждой ячейке массива, начиная с конца
    //1. Поиск ячейки в которой есть хотя бы одна 1
    //1. Объявляем переменные mask и maskCounter
    //2. Перебираем все битовые маски с одной 1, начиная с самого правого бита (31) и двигаясь к левому (0).
    // Формируем mask, в которой один бит сдвигается влево на количество позиций, определяемых maskCounter
    // Как только находим первую единицу((set[i] & mask) != 0), возвращаем число, которому она эквивалентна в массиве (32 * i + j), где i - индекс текущего элемента массива, а j - индекс текущей позиции бита
    // Увеличиваем maskCounter
    // Если массив пустой, выбрасываем исключение
    public int Max(){
        for (int i = set.length - 1; i >= 0; i--) { // Идем по каждой ячейке массива, начиная с последней
            if (set[i] != 0) { // Ищем ту, в которой есть хоть одна 1
                int mask;
                int maskCounter = 0;
                for (int j = 31; j >= 0; j--) { // Перебираем все маски с одной 1 справа налево
                    mask =  1 << maskCounter;
                    if ((set[i] & mask) != 0){ // Как только нашли первую единицу, возвращаем число, которому она эквивалентна в массиве
                        return (32 * i + j);
                    }
                    maskCounter++;
                }
            }
        }
        throw new RuntimeException("Set is empty");
    }

    public boolean Equal(Set B){
        return equal(B);
    }

    //1. Проверяется, равны ли оба множества. Если равны, возвращается значение "false".
    //2. Проверяется, существуют ли оба множества. Если хотя бы одно из множеств не существует, возвращается значение "false".

    //3. Проверяем, пересекаются ли интервалы множеств(сравнивая начало и конец текущего и множества b), если нет, сразу вернем false
    //4. Проверяем множества на пересечение
    //5. Выбираем множество, в котором 1 встречается раньше оставшиеся записываем в другую переменную
    //6. Находим позицию начала пересечения двух множеств

    //3 проверки
    //7. Проверяем левую часть на нули (не входящую в пересечение)
    // Если там есть хотя бы одна 1, множества не могут быть равны

    //8. Проверяем пересечение

    //9. Проверяем оставшуюся часть множества, end которой оказалась дальше
    // Если там есть хотя бы одна 1, множества не могут быть равны

    // Если все проверки пройдены, возвращаем true
    private boolean equal(Set b){
        if (b == null && this==null) return true; // Проверяем корректность
        else if (b==null || this == null) return false;
        if (end < b.start || b.end < start)
            return false;
        Set leftSet = start < b.start? this : b; // Выбираем то множество, в котором 1 встречается раньше
        Set secondSet = start < b.start? b : this;
        int intersectionStart = leftSet.findPos(secondSet.start).index;
        for (int i = 0; i < intersectionStart; i++){ // Проверяем левую часть на ноли (не входящую в пересечение)
            if (leftSet.set[i] != 0) // Если там есть хотя бы одна 1, множества не могут быть равны
                return false;
        }
        //Проверяем пересечение
        int secondSetIntersectionStart = leftSet.findPos(intersectionStart).index; // Начало второго множества
        int intersectionEnd = secondSet.findPos(Math.min(end, b.end)).index; // Выбираем конец того множества, которое кончается раньше
        for (int i = intersectionStart; i < intersectionEnd; i++){
            if (leftSet.set[i] != secondSet.set[secondSetIntersectionStart]) // Если значения четырехбайтовых чисел не совпадают, возвращаем false
                return false;
            secondSetIntersectionStart++;
        }
        //Проверяем оставшуюся часть множества, end которого оказался дальше
        secondSet = end < b.end? b : this;
        leftSet = end < b.end? this : b;
        intersectionEnd = secondSet.findPos(leftSet.end).index;
        for (int i = intersectionEnd + 1; i < secondSet.findPos(end).index; i++){
            if (secondSet.set[i] != 0) // Если в нем есть хотя бы одна 1 после пересечения, множества не могут быть равны
                return false;
        }
        return true; // Если все проверки пройдены, возвращаем true
    }

    //1. Проверяем, пусто ли текущее множество (this), или х находится вне его границ
    //1. Находим позицию x в B множества с помощью findPos()
    //2. Проверяем, существует ли позиция (не равна 0) и если да, возвращаем множество B

    //2. Проверяем, пусто ли множество B, или х находится вне его границ
    //1. Находим позицию x в текущем множестве с помощью findPos()
    //2. Проверяем, существует ли позиция (не равна 0) и если да, возвращаем текущее множество

    //3. Возвращаем null, если такого элемента нет ни в одном из множеств
    public Set Find(Set a, int x){
        if(isEmpty() || (x < start || x > end)){ // Если this пустое, или х вне его границ
            Position p = a.findPos(x);
            if (isNotZero(p)) {
                return a;
            }
        }

        if(a.isEmpty() || (x < a.start || x > a.end)){ // Если a пустое, или х вне его границ
            Position p = findPos(x);
            if (a.isNotZero(p)) {
                return this;
            }
        }
        return null;
    }

    //Побитовое ИЛИ
    //1. Создание нового множества C с определением самого левого start и самого правого end из множеств B и А
    //2. Проход по множеству A, выполняя побитовое ИЛИ и добавляя все элементы в множество C,
    //3. Проход по множеству B, выполняя побитовое ИЛИ и добавляя все элементы в множество C
    //4. Возвращение нового множества С
    private Set AorB(Set B){
        Set C = new Set(Math.min(B.start, start), Math.max(B.end, end));

        int counter = 0;
        for (int i = C.findPos(start).index; i <= C.findPos(end).index; i++){
            C.set[i] |= set[counter];
            counter++;
        }

        counter = 0;
        for (int i = C.findPos(B.start).index; i <= C.findPos(B.end).index; i++){
            C.set[i] |= B.set[counter];
            counter++;
        }

        return C;
    }

    //Вывод общего подмножества А и В
    //1. Определение начала(максимум из start множества B и start множества А)
    // и конца(минимум из end множества B и end множества А) - inter_start и inter_end
    //2. Создаем новое множество С с интервалом пересечения найденными началом и концом

    //3. Находим позиции начала пересечения в каждом множестве используя findPos(inter_start)
    //4. Проходим по интервалу пересечения множеств(inter_start и inter_end)
    // и выполняем операцию побитового И для каждого элемента, добавляя результат в множество С
    //5. Возвращаем новое множество С
    private Set AinB(Set B){
        int intersectionStart = Math.max(B.start, start); // Выбираем начало пересечения с самым правым start и самым левым end
        int intersectionEnd = Math.min(B.end, end);

        Set C = new Set(intersectionStart, intersectionEnd); // Определяем новое множество

        int firstSetStart = findPos(intersectionStart).index; // Находим позиции, с которых будет начинаться пересечение в каждом множестве
        int secondSetStart = B.findPos(intersectionStart).index;


        for (int i = intersectionStart; i <= intersectionEnd; i++){ // Проходим по зоне пересечения, делая побитовые и для каждого элемента, добавляем результат в С
            C.set[i] = set[firstSetStart] & C.set[secondSetStart];
            firstSetStart++;
            secondSetStart++;
        }
        return C;
    }

    //Побитовая разность А и В
    //1. Создаем новое множество, равное множеству А

    //2. Определяем начало второго множества
    //3. Находим конец пересечения, если end меньше или равен B.end. Иначе используем метод findPos(B.end).index

    //4. Проходим по C (равному А) и вычитаем все элементы множества В (для этого делаем побитовое И отрицания ячейки В)
    //5. Возвращаем новое множество С
    private Set AsubB(Set B){
        Set C = new Set(this); // Создаем новое множество, равное A

        int secondSetStart = B.findPos(start).index; // Определяем начало второго сета и конца их пересечения
        int intersectionEnd = end <= B.end ? end : findPos(B.end).index;

        for (int i = 0; i < intersectionEnd; i++){ // Проходим по С (равному А) и вычитаем все элементы множества, которые есть в В (для этого делаем побитовое И отрицания ячейки В)
            C.set[i] = set[i] & ~(B.set[secondSetStart]) ;
            secondSetStart++;
        }

        return C; // Возвращаем новое множество
    }

    //Поиск позиции
    //1. Берем х по модулю

    //3 случая
    //1. Если старт в 0 - возвращаем новую позицию index = x / 32 и pos = x % 32
    //2. Если старт < нуля - возвращаем новую позицию index = pos_zero + x / 32 и pos = x % 32
    //3. Если старт > 0 - возвращаем новую позицию index = (x - start) / 32 и pos = (x - start) % 32)2
    private Position findPos(int x){ // Поиск в массиве позиции для x
        x = Math.abs(x);

        // (32 бита хранится в одной ячейке)
        //если старт в 0
        if (start == 0)
            return new Position(x / 32, x % 32);

        //если старт меньше нуля
        if (start < 0)
            return new Position(pos_zero + x/32, x%32);

        //если старт > 0
        return new Position((x - start) / 32, (x - start) % 32);
    }

    //Внутренний метод для проверки множества на пустоту
    /*
    //Проверка в цикле до конца на неравенство 0
    //1. Если найдена такое число - вывод false
    //2. Иначе - вывод true

    private boolean isEmpty(){
        for (int i = 0; i < set.length; i++){
            if (set[i] != 0) return false;
        }
        return true;
    }

    public void print(){ // Вывод на экран
        System.out.println("Zero at: " + pos_zero);
        System.out.println("Start: " + start + " | End: " + end);
        for (int i = 0; i < set.length; i ++)
            System.out.print(Integer.toBinaryString(set[i]) + " ");
        System.out.println();
    }
}
*/